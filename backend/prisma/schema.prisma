generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                        String           @id @default(uuid())
  email                     String           @unique
  password                  String
  name                      String
  role                      String           @default("user") // user, admin
  age                       Int?
  bio                       String?
  city                      String?
  avatar                    String?
  phone                     String?          // Teléfono para verificación
  phoneVerified             Boolean          @default(false)
  hasPartner                Boolean?         // tiene pareja
  hasChildren               Boolean?         // tiene hijos
  childrenAges              String?          // edades de los hijos (ej: "5, 8, 12")
  verified                  Boolean          @default(false) // email verified
  emailVerificationToken    String?
  emailVerificationExpires  DateTime?
  passwordResetToken        String?
  passwordResetExpires      DateTime?
  termsAcceptedAt           DateTime?        // Fecha de aceptación de términos y privacidad
  twoFactorSecret           String?          // Secret para TOTP 2FA
  twoFactorEnabled          Boolean          @default(false)
  // Sistema de verificación de identidad
  identityVerified          Boolean          @default(false)
  verificationLevel         VerificationLevel @default(NONE)
  // Sistema de strikes y bans
  strikes                   Int              @default(0)
  bannedAt                  DateTime?
  banReason                 String?
  // Sistema de referidos
  referralCode              String?          @unique
  referredById              String?
  referredBy                User?            @relation("UserReferrals", fields: [referredById], references: [id], onDelete: SetNull)
  referrals                 User[]           @relation("UserReferrals")
  referralCreditsEarned     Float            @default(0)
  // Preferencias de moneda
  preferredCurrency         Currency         @default(EUR)
  createdAt                 DateTime         @default(now())
  updatedAt                 DateTime         @updatedAt
  experiences        Experience[]
  matchesAsHost      Match[]          @relation("MatchHost")
  matchesAsRequester Match[]          @relation("MatchRequester")
  messagesSent       Message[]
  reviewsGiven       Review[]         @relation("ReviewAuthor")
  reviewsReceived    Review[]         @relation("ReviewTarget")
  transactions       Transaction[]
  preferences        UserPreference[]
  wallet             Wallet?
  favorites          Favorite[]
  reports            Report[]
  blockedUsers            BlockedUser[]            @relation("UserBlocks")
  blockedByUsers          BlockedUser[]            @relation("UserBlockedBy")
  notifications           Notification[]
  pushSubscriptions       PushSubscription[]
  notificationPreferences NotificationPreference?
  badges                  UserBadge[]
  discountUsages          DiscountUsage[]
  auditLogs               AuditLog[]
  favoriteFestivals       FavoriteFestival[]
  searchHistory           SearchHistory[]
  quickReplies            QuickReply[]
  preferredLang           String?            @default("es")
  // Relaciones para disputas
  disputesOpened          Dispute[]            @relation("DisputeOpenedBy")
  disputesReceived        Dispute[]            @relation("DisputeRespondent")
  disputesResolved        Dispute[]            @relation("DisputeResolvedBy")
  disputeMessages         DisputeMessage[]
  // Relaciones para cancelaciones
  cancellations           Cancellation[]
  // Relaciones para verificación de identidad
  identityVerification    IdentityVerification?
  verificationsApproved   IdentityVerification[] @relation("VerificationVerifiedBy")

  @@map("users")
}

model UserPreference {
  id        String   @id @default(uuid())
  userId    String
  category  String
  value     String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, category, value])
  @@map("user_preferences")
}

model Festival {
  id           String             @id @default(uuid())
  name         String             @unique
  city         String
  startDate    DateTime?
  endDate      DateTime?
  description  String?
  imageUrl     String?
  region       String?            // Comunidad autonoma: "Andalucia", "Cataluna", etc.
  festivalType String?            // "religioso", "tradicional", "gastronomico", "musical"
  latitude     Float?
  longitude    Float?
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt
  experiences  Experience[]
  favoritedBy  FavoriteFestival[]

  @@map("festivals")
}

model Experience {
  id              String                   @id @default(uuid())
  title           String
  description     String
  festivalId      String?                  // Opcional - puede ser experiencia sin festividad
  category        ExperienceCategory       @default(cultura) // Categoría obligatoria
  city            String
  latitude        Float?                   // Coordenadas de la ciudad
  longitude       Float?
  price           Float?
  currency        Currency                 @default(EUR)     // Moneda del precio
  type            String
  hostId          String
  photos          String[]
  highlights      String[]
  capacity        Int                      @default(1)
  published       Boolean                  @default(true)
  avgRating       Float                    @default(0)
  reviewCount     Int                      @default(0)
  // Campos para busqueda avanzada (FASE 3)
  languages       String[]                 // Idiomas que habla el host: ["es", "en", "fr"]
  accessibility   String[]                 // Opciones: ["wheelchair", "hearing_aid", "visual_aid"]
  // Campos para grupos (FASE 4)
  minParticipants Int                      @default(1)
  maxParticipants Int?                     // null = usa capacity
  // Política de cancelación (FASE 7)
  cancellationPolicy CancellationPolicy    @default(FLEXIBLE)
  createdAt       DateTime                 @default(now())
  updatedAt       DateTime                 @updatedAt
  availability    ExperienceAvailability[]
  festival        Festival?                @relation(fields: [festivalId], references: [id])
  host            User                     @relation(fields: [hostId], references: [id], onDelete: Cascade)
  matches         Match[]
  reviews         Review[]
  favorites       Favorite[]
  groupPricing    GroupPricing[]

  @@index([festivalId])
  @@index([hostId])
  @@index([type])
  @@index([category])
  @@index([published])
  @@index([city])
  @@index([createdAt])
  @@map("experiences")
}

model ExperienceAvailability {
  id           String     @id @default(uuid())
  experienceId String
  date         DateTime
  available    Boolean    @default(true)
  createdAt    DateTime   @default(now())
  experience   Experience @relation(fields: [experienceId], references: [id], onDelete: Cascade)

  @@unique([experienceId, date])
  @@map("experience_availability")
}

model Match {
  id                    String        @id @default(uuid())
  experienceId          String
  requesterId           String
  hostId                String
  status                String        @default("pending")
  paymentStatus         String?       // pending, held, released, refunded
  hostConfirmed         Boolean       @default(false)    // anfitrion ha confirmado
  requesterConfirmed    Boolean       @default(false)    // viajero ha confirmado
  startDate             DateTime?
  endDate               DateTime?
  reminderOneDaySent    Boolean       @default(false)
  reminderThreeDaysSent Boolean       @default(false)
  // Campos para grupos (FASE 4)
  participants          Int           @default(1)
  participantNames      String[]      // Nombres opcionales de los participantes
  totalPrice            Float?        // Precio total calculado
  currency              Currency      @default(EUR) // Moneda de la transacción
  createdAt             DateTime      @default(now())
  updatedAt             DateTime      @updatedAt
  experience            Experience    @relation(fields: [experienceId], references: [id], onDelete: Cascade)
  host                  User          @relation("MatchHost", fields: [hostId], references: [id], onDelete: Cascade)
  requester             User          @relation("MatchRequester", fields: [requesterId], references: [id], onDelete: Cascade)
  messages              Message[]
  transactions          Transaction[]
  // Relaciones para disputas y cancelaciones
  disputes              Dispute[]
  cancellation          Cancellation?

  @@unique([experienceId, requesterId])
  @@index([experienceId])
  @@index([requesterId])
  @@index([hostId])
  @@index([status])
  @@index([createdAt])
  @@index([startDate])
  @@map("matches")
}

model Message {
  id            String      @id @default(uuid())
  matchId       String
  senderId      String
  content       String
  read          Boolean     @default(false)
  // Campos para chat mejorado (FASE 5)
  type          MessageType @default(TEXT)
  voiceUrl      String?     // URL del audio en Cloudinary
  voiceDuration Int?        // Duracion en segundos
  latitude      Float?      // Para ubicacion
  longitude     Float?      // Para ubicacion
  locationName  String?     // Nombre del lugar
  originalLang  String?     // Codigo de idioma original
  translations  Json?       // Cache de traducciones {"es": "...", "en": "..."}
  createdAt     DateTime    @default(now())
  match         Match       @relation(fields: [matchId], references: [id], onDelete: Cascade)
  sender        User        @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@index([matchId])
  @@index([createdAt])
  @@index([matchId, createdAt])
  @@map("messages")
}

model Transaction {
  id          String   @id @default(uuid())
  userId      String
  matchId     String?
  otherUserId String?  // ID del otro usuario en transacciones de platform_fee
  type        String
  amount      Float
  currency    Currency @default(EUR)
  status      String   @default("pending")
  stripeId    String?  @unique
  paypalId    String?  @unique
  description String?
  // Campos para PayPal
  paypalOrderId String? @unique // ID de orden de PayPal para captura
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  match       Match?   @relation(fields: [matchId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([type])
  @@index([status])
  @@index([createdAt])
  @@index([userId, createdAt])
  @@map("transactions")
}

model Wallet {
  id        String   @id @default(uuid())
  userId    String   @unique
  balance   Float    @default(0)
  currency  Currency @default(EUR)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("wallets")
}

model Review {
  id              String     @id @default(uuid())
  experienceId    String
  authorId        String
  targetId        String
  rating          Int
  comment         String?
  hostResponse    String?    // Respuesta del anfitrion
  hostResponseAt  DateTime?  // Fecha de la respuesta
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt
  author          User       @relation("ReviewAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  experience      Experience @relation(fields: [experienceId], references: [id], onDelete: Cascade)
  target          User       @relation("ReviewTarget", fields: [targetId], references: [id], onDelete: Cascade)

  @@unique([experienceId, authorId])
  @@map("reviews")
}

model Favorite {
  id           String          @id @default(uuid())
  userId       String
  experienceId String
  createdAt    DateTime        @default(now())
  user         User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  experience   Experience      @relation(fields: [experienceId], references: [id], onDelete: Cascade)
  alert        FavoriteAlert?

  @@unique([userId, experienceId])
  @@map("favorites")
}

// Alertas de disponibilidad para favoritos
model FavoriteAlert {
  id           String    @id @default(uuid())
  favoriteId   String    @unique
  enabled      Boolean   @default(true)
  lastNotified DateTime?
  favorite     Favorite  @relation(fields: [favoriteId], references: [id], onDelete: Cascade)

  @@map("favorite_alerts")
}

// Favoritos de festivales
model FavoriteFestival {
  id         String   @id @default(uuid())
  userId     String
  festivalId String
  createdAt  DateTime @default(now())
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  festival   Festival @relation(fields: [festivalId], references: [id], onDelete: Cascade)

  @@unique([userId, festivalId])
  @@map("favorite_festivals")
}

model Report {
  id            String      @id @default(uuid())
  reporterId    String
  reportedType  String      // user, experience, match
  reportedId    String
  reason        String      // spam, inappropriate, fraud, harassment, other
  description   String?
  status        String      @default("pending") // pending, reviewed, resolved, dismissed
  adminNotes    String?
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  resolvedAt    DateTime?
  reporter      User        @relation(fields: [reporterId], references: [id], onDelete: Cascade)

  @@map("reports")
}

model BlockedUser {
  id          String   @id @default(uuid())
  blockerId   String
  blockedId   String
  reason      String?
  createdAt   DateTime @default(now())
  blocker     User     @relation("UserBlocks", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked     User     @relation("UserBlockedBy", fields: [blockedId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
  @@map("blocked_users")
}

model Notification {
  id        String   @id @default(uuid())
  userId    String
  type      String   // match_request, match_accepted, match_rejected, new_message, reminder, review_request, system
  title     String
  message   String
  data      Json?    // Datos adicionales (matchId, experienceId, etc.)
  read      Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, read])
  @@index([userId, createdAt])
  @@map("notifications")
}

model PushSubscription {
  id         String   @id @default(uuid())
  userId     String
  endpoint   String   @unique
  p256dh     String   // Clave pública para encriptación
  auth       String   // Token de autenticación
  userAgent  String?
  createdAt  DateTime @default(now())
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("push_subscriptions")
}

model NotificationPreference {
  id                   String  @id @default(uuid())
  userId               String  @unique
  // Email preferences
  emailNewMatch        Boolean @default(true)
  emailMatchAccepted   Boolean @default(true)
  emailMatchRejected   Boolean @default(true)
  emailNewMessage      Boolean @default(true)
  emailReminders       Boolean @default(true)
  emailReviewRequest   Boolean @default(true)
  emailMarketing       Boolean @default(false)
  // Push preferences
  pushNewMatch         Boolean @default(true)
  pushMatchAccepted    Boolean @default(true)
  pushNewMessage       Boolean @default(true)
  pushReminders        Boolean @default(true)
  user                 User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notification_preferences")
}

// ============================================
// FASE 5: Funcionalidades de Negocio
// ============================================

model Badge {
  id          String      @id @default(uuid())
  code        String      @unique // verificado, anfitrion_estrella, viajero_frecuente, primera_fiesta, perfil_completo
  name        String
  description String
  icon        String      // emoji o URL del icono
  criteria    Json?       // Criterios para obtener el badge (ej: {"minReviews": 5, "minRating": 5})
  category    String      @default("achievement") // achievement, verification, milestone
  sortOrder   Int         @default(0)
  active      Boolean     @default(true)
  createdAt   DateTime    @default(now())
  users       UserBadge[]

  @@map("badges")
}

model UserBadge {
  id        String   @id @default(uuid())
  userId    String
  badgeId   String
  earnedAt  DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  badge     Badge    @relation(fields: [badgeId], references: [id], onDelete: Cascade)

  @@unique([userId, badgeId])
  @@index([userId])
  @@map("user_badges")
}

model DiscountCode {
  id          String          @id @default(uuid())
  code        String          @unique
  type        String          // percentage, fixed
  value       Float           // Porcentaje o cantidad fija
  minAmount   Float?          // Monto minimo para aplicar
  maxUses     Int?            // Usos maximos totales
  maxUsesPerUser Int          @default(1) // Usos maximos por usuario
  usedCount   Int             @default(0)
  validFrom   DateTime        @default(now())
  expiresAt   DateTime?
  active      Boolean         @default(true)
  description String?
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  usages      DiscountUsage[]

  @@map("discount_codes")
}

model DiscountUsage {
  id             String       @id @default(uuid())
  discountCodeId String
  userId         String
  amount         Float        // Monto descontado
  transactionId  String?      // ID de la transaccion donde se aplico
  usedAt         DateTime     @default(now())
  discountCode   DiscountCode @relation(fields: [discountCodeId], references: [id], onDelete: Cascade)
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([discountCodeId])
  @@index([userId])
  @@map("discount_usages")
}

// ============================================
// FASE 6: Admin y Analiticas
// ============================================

model AuditLog {
  id          String   @id @default(uuid())
  userId      String?  // Usuario que realizo la accion (null si fue sistema)
  action      String   // login, logout, create, update, delete, ban, unban, etc.
  entity      String   // user, experience, match, transaction, report, etc.
  entityId    String?  // ID de la entidad afectada
  data        Json?    // Datos adicionales (cambios realizados, valores anteriores, etc.)
  ipAddress   String?  // Direccion IP del usuario
  userAgent   String?  // User agent del navegador
  createdAt   DateTime @default(now())
  user        User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([action])
  @@index([entity])
  @@index([createdAt])
  @@map("audit_logs")
}

// ============================================
// FASE 3: Mejoras en Busqueda
// ============================================

model SearchHistory {
  id        String   @id @default(uuid())
  userId    String
  query     String
  filters   Json?    // Filtros aplicados
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@map("search_history")
}

// ============================================
// FASE 4: Experiencias Grupales
// ============================================

model GroupPricing {
  id             String     @id @default(uuid())
  experienceId   String
  minPeople      Int        // Desde X personas
  maxPeople      Int?       // Hasta Y personas (null = sin limite)
  pricePerPerson Float      // Precio por persona en este rango
  experience     Experience @relation(fields: [experienceId], references: [id], onDelete: Cascade)

  @@index([experienceId])
  @@map("group_pricing")
}

// ============================================
// FASE 5: Chat Mejorado
// ============================================

enum MessageType {
  TEXT
  VOICE
  LOCATION
  QUICK_REPLY
}

enum ExperienceCategory {
  gastronomia
  cultura
  naturaleza
  aventura
  nocturna
  familiar
}

enum CancellationPolicy {
  FLEXIBLE        // 100% hasta 24h antes
  MODERATE        // 100% hasta 72h, 50% hasta 24h
  STRICT          // 100% hasta 7d, 50% hasta 72h, 0% después
  NON_REFUNDABLE  // Sin reembolso
}

enum DisputeReason {
  NO_SHOW
  EXPERIENCE_MISMATCH
  SAFETY_CONCERN
  PAYMENT_ISSUE
  COMMUNICATION
  OTHER
}

enum DisputeStatus {
  OPEN
  UNDER_REVIEW
  RESOLVED_REFUND
  RESOLVED_PARTIAL_REFUND
  RESOLVED_NO_REFUND
  CLOSED
}

enum VerificationStatus {
  PENDING
  VERIFIED
  REJECTED
}

enum DocumentType {
  DNI
  PASSPORT
  DRIVER_LICENSE
}

enum VerificationLevel {
  NONE
  BASIC       // Email verificado
  PHONE       // Email + teléfono verificado
  IDENTITY    // Email + teléfono + documento
  FULL        // Todo verificado + verificación manual
}

enum Currency {
  EUR
  USD
  GBP
}

model QuickReply {
  id        String   @id @default(uuid())
  userId    String
  text      String
  emoji     String?  // Emoji opcional para identificar
  sortOrder Int      @default(0)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("quick_replies")
}

// ============================================
// FASE 7: Sistema de Disputas
// ============================================

model Dispute {
  id              String          @id @default(uuid())
  matchId         String
  openedById      String          // Usuario que abre la disputa
  respondentId    String          // Usuario contra quien se abre
  reason          DisputeReason
  description     String
  status          DisputeStatus   @default(OPEN)
  evidence        Json?           // URLs de fotos/capturas como evidencia
  resolution      String?         // Descripción de la resolución
  resolvedById    String?         // Admin que resuelve
  refundAmount    Float?          // Monto reembolsado si aplica
  refundPercentage Float?         // Porcentaje reembolsado
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  resolvedAt      DateTime?
  match           Match           @relation(fields: [matchId], references: [id], onDelete: Cascade)
  openedBy        User            @relation("DisputeOpenedBy", fields: [openedById], references: [id], onDelete: Cascade)
  respondent      User            @relation("DisputeRespondent", fields: [respondentId], references: [id], onDelete: Cascade)
  resolvedBy      User?           @relation("DisputeResolvedBy", fields: [resolvedById], references: [id], onDelete: SetNull)
  messages        DisputeMessage[]

  @@index([matchId])
  @@index([openedById])
  @@index([respondentId])
  @@index([status])
  @@index([createdAt])
  @@map("disputes")
}

model DisputeMessage {
  id        String   @id @default(uuid())
  disputeId String
  senderId  String
  content   String
  isAdmin   Boolean  @default(false) // Si es mensaje de admin
  attachments Json?  // URLs de archivos adjuntos
  createdAt DateTime @default(now())
  dispute   Dispute  @relation(fields: [disputeId], references: [id], onDelete: Cascade)
  sender    User     @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@index([disputeId])
  @@index([senderId])
  @@index([createdAt])
  @@map("dispute_messages")
}

// ============================================
// FASE 7: Sistema de Cancelaciones
// ============================================

model Cancellation {
  id               String             @id @default(uuid())
  matchId          String             @unique
  cancelledById    String             // Usuario que cancela
  reason           String?
  policy           CancellationPolicy // Política aplicada
  originalAmount   Float              // Monto original de la reserva
  refundPercentage Float              // Porcentaje reembolsado (0-100)
  refundAmount     Float              // Monto reembolsado
  penaltyAmount    Float              // Monto retenido como penalización
  processedAt      DateTime?          // Cuando se procesó el reembolso
  createdAt        DateTime           @default(now())
  match            Match              @relation(fields: [matchId], references: [id], onDelete: Cascade)
  cancelledBy      User               @relation(fields: [cancelledById], references: [id], onDelete: Cascade)

  @@index([cancelledById])
  @@index([createdAt])
  @@map("cancellations")
}

// ============================================
// FASE 7: Verificación de Identidad
// ============================================

model IdentityVerification {
  id              String             @id @default(uuid())
  userId          String             @unique
  status          VerificationStatus @default(PENDING)
  documentType    DocumentType
  documentFront   String             // URL en Cloudinary (carpeta privada)
  documentBack    String?            // URL en Cloudinary (opcional para pasaporte)
  selfie          String?            // URL de selfie con documento
  verifiedAt      DateTime?
  verifiedById    String?            // Admin que verifica
  rejectionReason String?
  attempts        Int                @default(1) // Número de intentos
  createdAt       DateTime           @default(now())
  updatedAt       DateTime           @updatedAt
  user            User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  verifiedBy      User?              @relation("VerificationVerifiedBy", fields: [verifiedById], references: [id], onDelete: SetNull)

  @@index([status])
  @@index([createdAt])
  @@map("identity_verifications")
}
